# checklist

## Goals
Write a parser and an interpreter for a 'checklist'.
Exact goals were left out but a few hints given:
This implementation of a 'checklist' may contain:
 * Raw text parsed as is and interpretered to it exact copy
 * headlines
 * function definitions and applications, function defs are removed from the output, function calls are substituted with their results
 * basic integer and logic operations
 * conditionals
 * three above points can be interpolated into raw text via `$`
 * indentation significant syntax inside functions
## Non-goals
Implementing a complete usable thing.

Possible example implementation should have demonstrated general programming skills, skills in functional programming, project management and testing skills of the applicant.

Internship subject was `Jetbrains IDEA Scala plugin improvements`

## Syntax rules/Правила(Russian, sorry...)

* checklist может содержать следующие выражения: строки, дефиниции функций, параметров; ввод, вывод из потока;
  вызовы функций, обращения(вставка) к параметрам, интерполяторы, условия, подзаголовки
* подзаголовки(entry) могут содержать все что checklist, кроме дефиниций функций
* все внутренние по отнощению к подзаголовкам, условиям(телу if и else), дефинициям функций выражения должны быть
  табулированы(используя только ПРОБЕЛЫ !) : табуляция последовательных выражений внутри родителя
  должна быть попарно равна и определяется по первому выражению внутри родителя
* пустые строки не учитываются
* дефиниции функций могут содержать все что подзаголовки, кроме самих подзаголовков
* все выражения читаются построчно
* тела условий могут содеражать все что дефиниции функций
* тела подзаголовков, функций, условий не должны быть пусты

## См. папку 'tests' для других примеров

Примеры варажений:

```
##это название чеклиста//самая первая строка в чеклисте
строка и символы () <<<===>>> //это комментарий(начинается с `//`), все что слева от `//` это одна строка, она будет распечатана как есть
//в строках запрещены символы $ # { } \n и наборы символов <- ->

любые
такие
строки
будут
распечатаны
как
есть


$$моя_функция(аргумент1, аргумент2)
    //тело табулируется
    любые
    такие
    строки
    будут
    распечатаны
    как
    есть
    $аргумент1 //
    $аргумент2 //обращение(вставка аргументов `аргументX`)
    это последнее выражение тела функции `моя функция`
это уже не тело функции
    и это тоже
    и это
$моя_функция("мой аргумент", "еще один")//при вызове функций и еще в нескольких случаях строки нужно записывать в `" "`
//также в этих же случаях можно записывать числа и булевы значения без `" "`
//например
$моя_функция(2.56, true)
$моя_функция("строка", "еще")

//условия:

$if{100 % 2 == 0}
    100 это четное число
$else
    100 это нечетное число
    
    
//внутри { } у условий запись такая же как при вызове функций, тоесть строки нужно записывать в `" "` можно использовать числа,
//булевы значения и как видно и примера - встроенные операторы
//полный список того что можно в таких случаях:
//строки,числа,булевы значения, операторы, вызов функций(уже без `$` впереди), вставка значений(тоже без доллара)
//сложное выражение внутри { } должно упрощаться к булевому значению, иначе это ошибка интерпретации
//символы `if` и `else` долны быть одинаковой табуляции чтобы быть связаными (else не может существовать без if) 
//встроенные бинарные операторы - это просто функции и их можно вызывать как функции:
$<=(1,2)
//это равносильно
${1 <= 2} //это интерполятор
//сразу примеры его использования:
моя обычная строка ${2 + 3 * 5 == 17 && (2+3) * 5 == 25} << это было вставлено прямо сюда
//встроенные унарные операторы тоже могут быть вызваны как функции:
${unary_-(1) == -1}
${unary_!(true) == !true}
следущие выражения равносильны:
${true == "true"}
${1.255 == "1.255"}
//булевы значения и числа изнутри хранятся как обычные строки, а операторы на вход которым подаются числа либо bool,
//просто приводят строку к нужному типу, если строку привести нельзя то это ошибка интерпретации
${true != "1"}
//бинарные операторы имеют ассоциативноть и приоритет
$var=моя строка//присвоение(создание) байндингу `var` значения `моя строка`
$var=$моя_функция(1,"<<<${1+1==2}>>>")
$var
<-ЭТО ВЫВОД В КОНСОЛЬ
->var//прочитать строку из inputstream в binding `var`
$var

#entry1
    #subentry1       //это подзаголовки
        bla bla
    ${1}

#entry2
    blah
    
    
``` 
